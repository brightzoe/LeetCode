# <center>荔枝刷题笔记<center>

## 算法时间复杂度

大 O 表示法指出了最糟情况下的运行时间，下面按从快到慢的顺序列出了你经常会遇到的 5 种大 O 运行时间。
❑ O(log n)，也叫对数时间，这样的算法包括二分查找。
❑ O(n)，也叫线性时间，这样的算法包括简单查找。
❑ O(n ＊ log n)，这样的算法包括快速排序———一种速度较快的排序算法。
❑ O(n2)，这样的算法包括选择排序———一种速度较慢的排序算法。
❑ O(n! )，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

## 链表

- 数据结构里，数组里的元素的地址是物理相连（一个紧挨一个），链表里的元素地址这种情况是逻辑上的相连（物理上未必挨着，但每个元素节点都知道下个节点的位置、即地址）`。
- 数组和链表都是容器，作用是存取数据，操作不外乎增删改查，数组的优势：查改，链表的优势：增删
- 单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0 - index 的。

## 树 二叉树

- 创建一个值为 val 的节点:

```js
function createTreeNode(val) {
  return {
    val: val,
    left: null,
    right: null,
  }
}
```

完全二叉树，链式位置与在数组中的位置完全一一对应。

- 数组方式表示与链式表达二叉树的转换：
  //TODO:紧凑型数组与二叉树的转换

```js
//将用数组表示的二叉树转换为链式表达的二叉树
//数组中根节点的为 array[i] 的二叉树转换为链式结构
function array2tree(array, i = 0) {
  if (array[i] == null) {
    return null
  }
  var root = createTreeNode(array[i])
  root.left = array2Tree(array, (i = 2 * i + 1))
  root.right = array2Tree(array, (i = 2 * i + 2))
  return root
}

//链式表达二叉树转换为数组表达
function tree2Array(root, ary = [], idx = 0) {
  if (root == null) {
    return
  }
  ary[idx] = root.val
  tree2Array(root.left, ary, idx * 2 + 1)
  tree2Array(root.right, ary, idx * 2 + 2)
  return ary
}

//将二叉树转换为紧凑型表示的数组
```

### 二叉树遍历

前中后指的是根节点在哪里。

- 前序遍历 MLR e.g.书本目录
  在链式结构中顺序画圈
  前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。
- 中序遍历 LMR
  在链式结构中竖向扫描
  中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。
- 后序遍历 LRM e.g.读完一本书的时间
  在链式结构中画圈不再见
  后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。

二叉树遍历的实现：递归和迭代

```js
//递归最容易，三种遍历很相似。
function preorderTraversal(root) {
  //递归前序遍历
  var array = []
  if (root) {
    array = [root.val]
    let array1 = preorderTraversal(root.left)
    let array2 = preorderTraversal(root.right)
    array = array.concat(array1).concat(array2)
  }
  return array
}
```

迭代前序遍历：
迭代利用栈记录遍历的过程，模拟递归的系统栈。

- 首先根入栈
- 将根节点出栈，将根节点值放入 res
- 然后遍历左子树、右子树，因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈
- 继续出栈（左子树被出栈）stack.pop()
- 依次循环(出栈遍历入栈)，直到栈为空，遍历完成

```js
function pre(root) {
  var stack = []
  var res = []
  root && stack.push(root) //root不为null则入栈
  while (stack.length > 0) {
    var curNode = stack.pop()
    res.push(curNode.val)
    curNode.right && stack.push(curNode.right)
    curNode.left && stack.push(curNode.left)
  }
  return res
}
//空间复杂度：O(n)
//时间复杂度：O(n)
```

中序遍历迭代算法

1. 先沿左侧全部入栈；node 定位到最左侧的小树，
2. node 出栈，进 res,node 变为右子树(左边第一颗小树的 right)，right 存在，right 进栈；重复 ①
3. 重复 ②

```js
function inorder(tree) {
  var res = []
  var stack = []
  var node = tree
  while (node) {
    stack.push(node)
    node = node.left
  }
  while (stack.length > 0) {
    var spop = stack.pop()
    res.push(spop.val)
    node = spop.right //向右移一个node

    while (node) {
      stack.push(node)
      node = node.left
    }
  }
  return res
}
```

//TODO: 不使用栈，如何实现一个前序遍历，只通过一个指针？

//后序遍历

### 排序二叉树/二叉搜索树 BST binary search tree

对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列，可以用来做排序算法。
判断是否是 BST：

如何向 BST 插入值

```js
function insertIntoBST(bst, val) {
  //向BST插入值val,并返回bst
  if (bst == null) {
    return createTreeNode(val)
  }
  if (val > bst.val) {
    bst.right = insertIntoBST(bst.right, val)
  } else {
    bst.left = insertIntoBST(bst.left, val)
  }
  return bst
}

function insertIntoBST2(bst, val) {
  //不使用递归
  if (bst == null) {
    return createTreeNode(val)
  }
  var p = bst
  while (true) {
    if (val < p.val) {
      if (p.left) {
        p = p.left
      } else {
        p.left = createTreeNode(val)
        break
      }
    }

    if (val > p.val) {
      if (p.right) {
        p = p.right
      } else {
        p.right = createTreeNode(val)
        break
      }
    }
  }
  return bst
}
```

平衡树
自平衡树：三种(AVL)，保证 bstsort 的效率
用 BST 为数组排序，BSTsort 是由插入排序优化得来
不同排序方法排序稳定性：
排序前后相同元素的相对顺序是否发生改变
稳定：可以保证不改变

- 冒泡排序：稳定
- 插入排序：稳定（BST）
- 快速排序：不稳定
- 选择排序：不稳定
- 归并排序：稳定

针对对象的排序，需要使用稳定排序，要先排次要列，最后排主要列。e.g. excel 排序有主要排序列，次要排序列，主要列的排序结果可以应用于第二个列。

将不稳定排序，改写为稳定排序：先把初始序列记录一份初始位置，不稳定排序后，把相同的元素，再小范围内重新排序。

## 二叉堆 heap 优先队列 priority queue

堆内存:动态分配的空间
栈内存:函数里的变量
二叉堆:一颗完全二叉树,如果表示为数组不会浪费空间
二叉堆分两种:小顶堆:每个父结点都小于等于它的左右子节点;大顶堆:每个父节点都大于等于它的左右子节点

1. 移除最值:移除数组中第一个元素,也就是根节点.**思路**:把最后一个元素移到根部,保持结构是完全二叉树,然后与左右较大的值交换,把它依次 sink down.
2. 插入值:先插入到数组最后的位置,然后将这个值与它的父节点交换,直到父节点小于插入的值. bubble up.
3. 把二叉树堆化.就地改成堆.
4. 堆排序

```js
class PriorQueue{
  constructor (){
    this.eles =[]
  }
  pick(){
    return this.eles[0]
  }
  push(val){
    this.eles.push(val)
    var idx = this.eles.legnth - 1
      var parentIdx = Math.floor((idx-1)/2)

    while(parentIdx >= 0){
      if(this.eles[idx] > this.eles[parentIdx]){
        this._swap(idx,parentIdx)
        idx = parentIdx
        parentIdx = Math.floor((idx-1)/2)
      }else{
        break
      }
    }

  }
  pop(){

  }
  _swap(i,j){
    id(i !== j){
      var t = this.eles[i]
      this.eles[i] = this.eles[j]
      this.eles[j] = t
    }
  }
}






```

## 哈希表 散列表 HashTable/HashMap
在O(1)的时间可以实现get,set,has操作
核心思路:直接通过key可以计算出其在数组里的存在位置,计算过程不涉及数组长度及其他元素的内容和位置
- 哈希冲突
- 哈希冲突不可避免,希望hash函数的计算结果随机且均匀
- 解决方案:开放地址法,重新哈希法,链表法


## 二分查找

- 识别二分查找：二分查找是一种在每次比较之后将查找空间一分为二的算法。每次需要查找集合中的索引或元素时，都应该考虑二分查找。如果集合是无序的，我们可以总是在应用二分查找之前先对其进行排序。
- 工作方式：在最简单的形式中，二分查找对具有指定左索引和右索引的连续序列进行操作。这就是所谓的查找空间。二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。

### 模板 1

初始条件：`left = 0, right = length-1`
终止：`left > right`
向左查找：`right = mid-1`
向右查找：`left = mid+1`
这是二分查找的最基础和最基本的形式。

```js
var search = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  while (left <= right) {
    let mid = Math.ceil((left + right) / 2)
    if (nums[mid] == target) {
      return mid
    }
    if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  return -1
}
```

### 69. x 的平方根

![](https://cdn.jsdelivr.net/gh/brightzoe/img/69.png)
注意：
不用 `mid * mid` 与 `x`进行比较，乘方有可能溢出，用`x / mid` 要注意`mid`不为 0。

## 排序问题

### 977. Squares of a Sorted Array

Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.
Example 1:
Input: [-4,-1,0,3,10]
Output: [0,1,9,16,100]

Example 2:
Input: [-7,-3,2,3,11]
Output: [4,9,9,49,121]

Note:

1. 1 <= A.length <= 10000
2. -10000 <= A[i] <= 10000
3. A is sorted in non-decreasing order.

Solution:

```js
var sortedSquares = function (A) {
  for (i = 0; i < A.length; i++) {
    A[i] = A[i] * A[i]
  }
  for (var j = A.length; j > 0; j--) {
    for (var i = 0; i < j; i++) {
      if (A[i] > A[i + 1]) {
        var tem = A[i]
        A[i] = A[i + 1]
        A[i + 1] = tem
      }
    }
  }
  return A
}
```

> 开始想到的就是从左到右，两个两个比较，把大的数往后丢，但一遍只能确保最大的在最后一个，不能确保整体顺序。用了两层循环，每次 (length-1) 次交换，循环有冗余，运行效率很慢。但是去掉冗余也很慢，大于 1s, 冒泡排序好慢。可以再进行优化 (i.e. 某次遍历不发生两数交换，已经得到有序数组，break 掉）
> TODO: 学习各种排序方法，比较运行效率

**冒泡排序**

- 比较相邻两个元素大小，如果第一个比第二个大，就交换他们
- 从头遍历到尾部，当一轮遍历完后，数组最后一个元素是最大的
- 除去最后一个元素，对剩余元素执行上述过程，每次把剩余元素中的最大值丢到后面。最后一遍遍历只剩第一个和第二个元素比较
- 遍历结束可确保数组升序
- 总共比较次数为 `length \* (length - 1) / 2`
- 时间复杂度为 O(n^2), 只需要有一个存放常量的空间，元素本身在原数组上进行交换，空间复杂度为 O(1)
  TODO: 学习复杂度--属于数据结构与算法

```js
var sortedSquares = function (A) {
  function sortNumber(a, b) {
    return a - b
  }
  for (i = 0; i < A.length; i++) {
    A[i] = A[i] * A[i]
  }
  var A = A.sort(sortNumber)
  return A
}
```

**array.sort() 排序原理**

- `array.sort()`省略参数会将之转换成字符串，按 Unicode 比较进行排序。所以不带参数对数字排序不准确。参数大于零，则交换相邻两数位置。
- 上面`sortNumber(a,b)`是一个回调函数，原理是冒泡排序，在数组中按序取相邻两个数进行比较，`a-b>0`, 则交换两数位置，小于等于 0 则不动。
- `return a - b;`代表升序；`return b - a;`代表降序；`return 1;`相当于`array.reverse()`

```js
var sortedSquares = function (A) {
  var minIndex = 0
  for (var i = 0; i < A.length; i++) {
    if (Math.abs(A[i]) < Math.abs(A[minIndex])) minIndex = i
  }
  var left = minIndex
  var right = left + 1
  var result = []
  while (left >= 0 && right < A.length) {
    if (Math.abs(A[left]) < Math.abs(A[right])) {
      result.push(A[left] * A[left])
      left--
    } else {
      result.push(A[right] * A[right])
      right++
    }
  }
  while (left >= 0) {
    result.push(A[left] * A[left])
    left--
  }
  while (right < A.length) {
    result.push(A[right] * A[right])
    right++
  }
  return result
}
```

> 特例，不是普遍排序解法。由于本题特点，数组中的值是 \/ 或 \ 或 / 的顺序，一般情况最小值在中间，向两边递减。所以此解法是先找到最小值的位置，然后向两边寻找第二小的数，依次追加到新数组中。

## 位运算 Bit Manipulation

TODO: 位运算掌握的不好

### 136、 Single Number

Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:
Input: [2,2,1]
Output: 1

Example 2:
Input: [4,1,2,1,2]
Output: 4

Solution:

```js
var singleNumber = function (nums) {
  var n = nums.length
  for (var i = 0; i < n; i++) {
    for (var j = i; j < n; j++) {
      if (i != j && nums[i] == nums[j]) {
        nums[i] = 0.1
        nums[j] = 0.1
      }
    }
  }

  for (var i = 0; i < n; i++) {
    if (nums[i] !== 0.1) {
      return nums[i]
    }
  }
}
```

> 数组里面都是整数。所以找出现两次的数，把它们都变成一个数组里不存在的值，此处为 0.1. 然后再遍历一遍，返回不为 0.1 的数。思路很简单，但运行效率炒鸡慢，接近 1s.

```js
var singleNumber = function (nums) {
  var a = 0
  for (var i = 0; i < nums.length; i++) {
    a ^= nums[i]
  }
  return a
}
```

> 位运算 `a ^= nums[i]`数组中所有的数进行异或，相同为 0, 不同为 1. 相同的全都消掉了，只剩一个单独得数。效率很高，但是一般不会想到

### 338. Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example 1:
Input: 5
Output: [0,1,1,2,1,2]

### 190. Reverse Bits

Reverse bits of a given 32 bits unsigned integer.

Example 1:
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

```js
var reverseBits = function (n) {
  let sum = 0
  for (let i = 0; i < 32; i++) {
    //把 n 的 2 进制的每一位反转给 sum
    let d = n % 2
    sum = sum * 2 + d
    n = n - d
    n >>= 1
  }
  return sum >>> 0 //去掉符号
}
```

> 回忆二进制表示：`0b00000010100101000001111010011100`二进制 `0b` 开头；八进制 `0` 开头；十六进制 `0x` 开头。(unsigned: 无符号的）首位为 1 的话，js 会返回负数，用`>>> 0`按位右移，不保留符号位，则返回对应正数

```js
var reverseBits = function (n) {
  let result = 0
  for (let i = 0; i < 31; i++) {
    result += n & 1
    n = n >> 1
    result = result << 1
  }
  result += n & 1
  return result >>> 0
}
```

> 全用位运算，从右到左每位 `&1`

> `num1[ i-- ] | 0`//一个精髓的位运算，有值返回它本身。undefined 返回 0

## 队列 先入先出 push() shift()

队列是典型的 FIFO 数据结构。插入（`insert`）操作也称作入队（`enqueue`），新元素始终被添加在队列的末尾。 删除（`delete`）操作也被称为出队（`dequeue`)。 你只能移除第一个元素。

### 循环队列

循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

### 队列和 BFS

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。

## 栈 stack 后入先出 push() pop()

栈是一个 LIFO 数据结构。将首先处理添加到队列中的最新元素。

### 20. 有效的括号

![](https://cdn.jsdelivr.net/gh/brightzoe/img/20.png)

> 分析这题判断是否有效的方法，遇左括号存入，遇右括号匹配则出列。符合后入先出，很经典的栈的题。
> Solution:

```js
var isValid = function (s) {
  //第一步，加一个判定，符合条件的 s.length 一定是偶数。
  if (s.length % 2) {
    return false
  }
  var ary = []
  for (let i of s) {
    if (i == '{' || i == '[' || i == '(') {
      ary.push(i)
    } else {
      if (
        (i == '}' && ary[ary.length - 1] == '{') ||
        (i == ']' && ary[ary.length - 1] == '[') ||
        (i == ')' && ary[ary.length - 1] == '(')
      ) {
        ary.pop()
      } else {
        //如果走到这一步，碰到一个右括号，前面没有对应的左括号，就可以判定 not valid.
        return false
      }
    }
  }
  return ary.length == 0
}
```

> 然后分析中间主题逻辑，`ary` 里面放的是左括号，后面要判断的是对应的右括号，为了判断方便，可以直接 `push` 对应右括号。

```js
for (let i of s) {
  if (i == '{') {
    ary.push('}')
    continue
  }
  if (i == '[') {
    ary.push(']')
    continue
  }
  if (i == '(') {
    ary.push(')')
    continue
  }
  if (i == ary[ary.length - 1]) {
    ary.pop()
  } else {
    return false
  }
}
```

> 最后一个 `if else` 优化：

```js
if (i !== ary.pop()) {
  return false
}
```

> 很多 `if`, 可以改成 `switch`。不过改成 switch 的话也不需要遇左括号存右括号了。

```js
var isValid = function (s) {
  if (s.length % 2) {
    return false
  }
  var ary = []
  for (let letter of s) {
    switch (letter) {
      case '{': {
        ary.push('}')
        break
      }
      case '[': {
        ary.push(']')
        break
      }
      case '(': {
        ary.push(')')
        break
      }
      case '}': {
        if (ary.pop() !== letter) {
          return false
        }
        break
      }
      case ']': {
        if (ary.pop() !== letter) {
          return false
        }
        break
      }
      case ')': {
        if (ary.pop() !== letter) {
          return false
        }
        break
      }
    }
  }
  return ary.length == 0
}
```

### 1221. Split a String in Balanced Strings

Balanced strings are those who have equal quantity of 'L' and 'R' characters.
Given a balanced string s split it in the maximum amount of balanced strings.
Return the maximum amount of splitted balanced strings.

Example 1:
Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.

Solution:

```js
var balancedStringSplit = function (s) {
  let stack = 0
  let result = 0
  for (let i = 0; i < s.length; i++) {
    if (s[i] == 'R') {
      stack++
    } else {
      stack--
    }
    if (stack == 0) {
      result++
    }
  }
  return result
}
```

> 分割平衡字符串，栈，easy。

## 高精度数组-数学运算

### 66、Plus One

Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:
Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.

Solution:

```js
var plusOne = function (digits) {
  var i = digits.length - 1
  digits[i]++
  for (; i > 0; i--) {
    if (digits[i] > 9) {
      digits[i] = 0
      digits[i - 1]++
    }
  }
  if (digits[0] > 9) {
    digits[0] = 0
    digits.unshift(1)
  }
  return digits
}
```

> 模拟数学计算，从最低位开始加，过 9 进 1；然后考虑特殊情况

```js
var plusOne = function (digits) {
  var i = digits.length - 1

  for (; i >= 0; i--) {
    if (digits[i] == 9) {
      digits[i] = 0
    } else {
      digits[i]++
      return digits
    }
  }
  digits.unshift(1)
  return digits
}
```

> 因为是加一，只有在最后一位为 9 的情况下才产生进位，进位都是 0.
